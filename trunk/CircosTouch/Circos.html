<html>
	<head>
		<title>	Circos Plots</title>
		<!--
			Imports
		-->
		<script type="text/javascript" src="Components.js"></script>
		<script type="text/javascript" src="CircosObjects.js"></script>
		<script type="text/javascript" src="GenomicBuild.js"></script>

		<!--
			This script is located on a remote server. It might be a good idea to move it to a local server.
			I was nervous about copyright protection, so I'm just loading it from the github site. However,
			it's quite possible the file will be removed.
		-->
		<script src="https://github.com/sidelab/interact/raw/master/interact.js"></script>
	</head>
	<body>
		<table>
		<tr>
		<td>circosPlot1</td>
		<td><canvas id="circosPlot1" width=500 height=500 style="border:1px dotted;float:left"></canvas></td?
		</tr>
		<tr>
		<td>circosPlot2</td>
		<td><canvas id="circosPlot2" width=500 height=500 style="border:1px dotted;float:left"></canvas></td?
		</tr>
		<tr>
		<td>circosPlot3</td>
		<td><canvas id="circosPlot3" width=500 height=500 style="border:1px dotted;float:left"></canvas></td?
		</tr>
		</table>
		<script type="text/javascript">
			var snd = new Audio("dingding.wav"); //run sound for the lulz :D
			snd.play();
		</script>
		<script type="text/javascript">

			//var file = "http://chaos-somanayr.googlecode.com/svn/trunk/CircosTouch/edges.txt"; 	//FIXME: Be sure to change this if the file is moved
																								//File must be on the same domain as the HTML file and script
			var file = "edges_excerpt.txt";
			/*
			 * Ideas for handlings lag due to large data sets:
			 * a) Data simplification. Already implemented in CircosObjects SelfContainedCircosPlot
			 * b) Save as image and modify image instead of re-rendering. Re-render on mouse up
			 * c) ???
			 */

			console.log("version: .53");

			var canvas = document.getElementById("circosPlot1");
			var canvasContext = canvas.getContext("2d");

			var realPlot; 	//the actual plot, not rendered
			var sccp;		//the simplified plot

			buildPlotFromFile(file, {curveRadius:200, chrOff:240, chrThickness:40, innerOff:200, innerThickness:40}, 500, 500, function(plot){realplot = plot; sccp = plot.simplify(); sccp.render(canvasContext)});

			var ua = navigator.userAgent;
			var isiPad = /iPad/i.test(ua) || /iPhone OS 3_1_2/i.test(ua) || /iPhone OS 3_2_2/i.test(ua);
			if(isiPad){
				/*
				 * Touch listeners
				 */
				var eventMonitor = INTERACT.watch(canvas, {
					detailed : true
				});
				var p1 = {
					col : "#00FF00",
					id : -1
				}, p2 = {
					col : "#0000FF",
					id : -1
				};
				var lastAngle = -1;
				var dist = -1;
				var angle = 0;
				var pos = -1;
				// handle pointer down events
				eventMonitor.bind('pointerDownMulti', function(evt, absXY, relXY) {
					var touchData = relXY;
					var p1Valid = false, p2Valid = false;
					while(touchData){
						if(touchData.id == p1.id){
							p1Valid = true;
						} else if (touchData.id == p2.id){
							p2Valid = true
	;					}
						touchData = touchData.next;
					} //we can't check with p1.id == relXY.id because if p1 is lifted off the canvas, the event does not register
					touchData = relXY;
					while(touchData) {
						//touch assignments to unused pointers
						if(!p1Valid) {
							p1.id = touchData.id;
							p1.x = touchData.x;
							p1.y = touchData.y;
							p1Valid = true;
						} else if(!p2Valid) {
							p2.id = touchData.id;
							p2.x = touchData.x;
							p2.y = touchData.y;
							p2Valid = true;
						}
						touchData = touchData.next;
					} // while
					angle = sccp.renderingRules.rotation; //default angle

					if(p1Valid && p2Valid){ //two touch case
						lastAngle = getAngle(p1, p2); //for reference
						dist = distance(p1,p2) / sccp.renderingRules.scale;
						pos = -1;
					}

					if((!p1Valid || !p2Valid) && (p1Valid || p2Valid)){ //one touch case -- check for one valid and one not valid. There is no XOR in JavaScript, but this is essentially XOR
						pos = touchData;
					}
				});



				/*
				 * FIXME: I'm pretty sure all the math here is right. There is some bugginess with zooming and rotating that I haven't been able to find the source of.
				 * It seems that if you pinch first, everything works OK. Panning first will bug on pinch/pan, rotating always involves some pinching or anti-pinching (is that a word???), anti-pinching first will cause the screen to go blank
				 */

				// handle moves
				eventMonitor.bind('pointerMoveMulti', function(evt, absXY, relXY) {
					var touchData = relXY;

					while(touchData) { //reassign locations
						if(touchData.id == p1.id) {
							p1.x = touchData.x;
							p1.y = touchData.y;
						} else if(touchData.id == p2.id) {
							p2.x = touchData.x;
							p2.y = touchData.y;
						}
						touchData = touchData.next;
					}
					if((p1.id == -1 || p2.id == -1) && (p1.id != -1 || p2.id != -1) && pos != -1){ //one touch
						var deltaX = pos.x - relXY.x; //calculate the change in finger position
						var deltaY = pos.y - relXY.y;
						sccp.center.x -= deltaX;
						sccp.center.y -= deltaY;
						pos = relXY;
						canvasContext.save();
						canvasContext.fillStyle = "#FFFFFF";
						canvasContext.fillRect(0,0,500,500);
						sccp.render(canvasContext);
						canvasContext.restore();
					} else if(p2.id != -1 && p1.id != -1){ //two touch
						var thisAngle = getAngle(p1, p2);
						angle += (thisAngle - lastAngle);
						angle %= Math.PI * 2;
						lastAngle = thisAngle;

						var thisDist = distance(p1, p2);//distance between the fingers
						var scale = thisDist / dist;
						sccp.renderingRules.scale = scale;
						sccp.renderingRules.rotation = angle;
						canvasContext.save();
						canvasContext.fillStyle = "#FFFFFF";
						canvasContext.fillRect(0,0,500,500);
						sccp.render(canvasContext);
						canvasContext.restore();
					}
				});

				// handle pointer up events
				eventMonitor.bind('pointerUpMulti', function(evt, absXY, relXY, deltaXY) {
					//free pointers so that they can be used for other touches
					if(relXY.id == p1.id) {
						p1.id = -1;
						dist = lastAngle = -1;
					}
					if(relXY.id == p2.id) {
						p2.id = -1;
						dist = lastAngle = -1;
					}
					pos = -1;
				});

				function distance(p1, p2){
					return Math.sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y));
				}
			} else {
				var lastAngle = undefined;
				var lastPos;

				/*
				 * Mouse listeners
				 */
				canvas.onmousedown = function(evt){
					var hit = sccp.getPlot().findHitByEvent(evt, canvasContext);
					var x = evt.clientX - canvas.offsetLeft;
					var y = evt.clientY - canvas.offsetTop;
					lastPos = {x:x, y:y};
					if(hit == null){
						lastAngle = getAngle(sccp.center, lastPos);
						return;
					}
					p.createSubPlot(document.getElementById("circosPlot2").getContext("2d"), hit.start, hit.end, 500, 500);
					cp.zoomInOnSection(document.getElementById("circosPlot3").getContext("2d"), hit.start, hit.end, 500, 500);
				}

				canvas.onmousemove = function(evt){
					if(!lastPos)
						return;
					var x = evt.clientX - canvas.offsetLeft;
					var y = evt.clientY - canvas.offsetTop;
					if(lastAngle){
						//spin
						var thisAngle = getAngle(sccp.center, {x:x, y:y});
						sccp.rotate(thisAngle - lastAngle);
					} else {
						//pan
						sccp.translate(lastPos.x - x, lastPos.y - y);
						lastPos = {x:x, y:y};
					}

					canvasContext.fillStyle = "#FFFFFF";
					canvasContext.fillRect(0,0,500,500);
					sccp.render(canvasContext);
				}

				canvas.onmouseup = function(evt){
					lastAngle = undefined;
					lastPos = undefined;
				}

				function mouseScroll(evt){
					wheelDelta = evt.detail ? evt.detail : evt.wheelData;
				}

				/* From http://www.javascriptkit.com/javatutors/onmousewheel.shtml */

				var mousewheelevt=(/Firefox/i.test(navigator.userAgent))? "DOMMouseScroll" : "mousewheel" //FF doesn't recognize mousewheel as of FF3.x

				if (canvas.attachEvent) //if IE (and Opera depending on user setting)
				    canvas.attachEvent("on"+mousewheelevt, mouseScroll)
				else if (canvas.addEventListener) //WC3 browsers
				    canvas.addEventListener(mousewheelevt, mouseScroll, false)

			}

			function getAngle(center, location){ // returns the angle in a circle relative to the center and the point. Radius is irrelevant
				var x = location.x - center.x;
				var y = location.y - center.y;
				if(x == 0 && y > 0)
					return Math.PI / 2;
				if(x == 0 && y < 0)
					return 3 * Math.PI / 2;
				if(y == 0 && x > 0)
					return 0;
				if(y == 0 && x < 0)
					return Math.PI;
				var angle = Math.atan(y/x);
				if(x > 0 && y > 0)
					return angle;
				if(x < 0)
					return Math.PI + angle
				return Math.PI * 2 + angle;
			}
		</script>
	</body>
</html>